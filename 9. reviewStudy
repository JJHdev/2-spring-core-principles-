1. 객체 지향 설계와 스프링
  1.1 다형성에서 역할과 구현으로 구분하면 편하다. 
    -> 로미오와 줄리엣에서 로미오 (역할)은 어떤 배우든지 할수 있다. (역할은 인터페이스), (배우는 구현객체) 여러 배우들이 모여 연극(어플리케이션)이 만들어지는데 만약 배우가 몸이 아파 다른 배우를 캐스팅해도 배우는 자신의 역할을 알고 익혀있으니 돌아갈수 있다.
    -> 클라이언트는 대상의 역할(인터페이스)만 알면되고, 구현 대상의 내부구조는 몰라도 된다.
    -> public class MemberService {
        // private MemberRepository memberRepository = new MemoryMemberRepository();
         private MemberRepository memberRepository = new JdbcMemberRepository();
      }
      코드로 보면 이렇게 표현할수 있다.
      
  1.2 OCP는 개방폐쇄의 원칙인데 확장에는 열려있으며, 변경에는 닫혀있어야 한다는것인데, 기능을 확장할려면 코드를 변경해야 하는데, 어떻게 그럴수있을까?
    -> public class MemberService {
        // private MemberRepository memberRepository = new MemoryMemberRepository();
         private MemberRepository memberRepository = new JdbcMemberRepository();
      } 1.2 위반
    
  1.3 DIP의존관계 역전의 원칙 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
    -> MemberRepository m = new MemoryMemberRepository(); 1.3 위반
    
  1.4 다형성 만으로는 OCP, DIP를 지킬 수 없다. 그리하여 스프링의 기술로 OCP, DIP를 지킬 수 있도록 해준다.. 


2. 스프링 핵심 원리 이해1 - 예제 만들기
  2.1 MemberService memberService = new MemberServiceImpl(); 이렇게 설계를 하면 구현객체에게 의존하게 된다. (구현객체가아닌 추상화에 의존해야한다.)

3. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용
  3.1 > 2.1에서 구현클래스에 의존하는 문제점을 확인할 수 있었다. 이를 해결할려면 어떻게 해야할까?
      > AppConfig의 등장으로 이를 해결할수 있다. (애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스를 만들자.) // Spring 애노테이션 사용하기전.
      > public class AppConfig {

            public MemberService memberService() {
                return new MemberServiceImpl(new MemoryMemberRepository());
            }
            public OrderService orderService() {
                return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
            }
        }
    > 위와 같은 설정으로 아래와 같이 의존관계를 맺을수 있게 되었다. (생성자로 통해서 의존관계를 맺어야 한다.)
      MemberServiceImpl MemoryMemberRepository
      OrderServiceImpl MemoryMemberRepository , FixDiscountPolicy

    3.2 실제 코드로 보자면 아래와 같다. (AppConfig class)
         private final MemberRepository memberRepository;
         private final DiscountPolicy discountPolicy;

         public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
             this.memberRepository = memberRepository;
             this.discountPolicy = discountPolicy;
         }

    3.3 실제 test코드에서는 아래와 같이 실행하면 된다. 
        AppConfig appConfig = new AppConfig();
        MemberService memberService = appConfig.memberService();

      0, AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너라 한다. 

    3.4 >> 3.3 처럼 객체를 사용해야하는데 이것을 스프링으로 전환해서 사용해보자 
      -. @Configuration
         public class AppConfig {
         
             @Bean
             public MemberService memberService() {
                 return new MemberServiceImpl(memberRepository());
             }
    
             @Bean
             public OrderService orderService() {
                 return new OrderServiceImpl( memberRepository(), discountPolicy());
             }
    
             @Bean
             public MemberRepository memberRepository() {
                 return new MemoryMemberRepository();
             }
             @Bean
             public DiscountPolicy discountPolicy() {
                 return new RateDiscountPolicy();
             }
        }

      -> @Configuration과 @Bean을 붙여준다.
      -> ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
         MemberService memberService = applicationContext.getBean("memberService", MemberService.class);

      -> 방식으로 사용이 가능하다. 

4. 스프링 컨테이너와 스프링 빈
    4.1 ApplicationContext를(+ BeanFactory) 스프링 컨테이너라 한다.그리고 이는 인터페이스다.
          -> 그리고 XML기반으로 만들수 있고, 애노테이션 기반의 자바 설정클래스로 만들수 있다.
    4.2  3.4처럼 스프링컨테이너 안에 Bean 안에 이름과 객체를 저장한다.
    4.3 

5. 싱글톤 컨테이너


6. 컴포넌트 스캔


7. 의존관계 자동 주입


8. 빈 생명주기 콜백


9. 빈 스코프
